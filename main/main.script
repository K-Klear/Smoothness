local INPUT = require("modules.input")

local smooth = 10
local base_step = 8
local jump_step = 16
local freq = 1
local update_timer
local next_freq = 0
local prev_pos

local state
local movement_vector = vmath.vector3(0, 0, 0)

local size = 80
local margin = 1

local function upd(self)
	local pos_override = {}
	local pos = go.get_world_position()
	local co_size = (size / 2)
	local ray_1, ray_2
	if INPUT.inputs[hash("left")] then
		ray_1 = physics.raycast(pos, pos + vmath.vector3(-co_size, -co_size + margin, 0), {hash("world")})
		ray_2 = physics.raycast(pos, pos + vmath.vector3(-co_size, co_size - margin, 0), {hash("world")})
		if not (ray_1 or ray_2) then
			movement_vector.x = -base_step
		else
			movement_vector.x = 0
		end
	elseif INPUT.inputs[hash("right")] then
		ray_1 = physics.raycast(pos, pos + vmath.vector3(co_size, -co_size + margin, 0), {hash("world")})
		ray_2 = physics.raycast(pos, pos + vmath.vector3(co_size, co_size - margin, 0), {hash("world")})
		if not (ray_1 or ray_2) then
			movement_vector.x = base_step
		else
			movement_vector.x = 0
		end
	else
		movement_vector.x = 0
	end



	ray_1 = physics.raycast(pos, pos + vmath.vector3(-co_size, -co_size, 0), {hash("world")})
	ray_2 = physics.raycast(pos, pos + vmath.vector3(co_size, -co_size, 0), {hash("world")})
	if not (ray_1 or ray_2) then
		movement_vector.y = movement_vector.y - (0.2 * freq)
	else
		movement_vector.y = 0
		state = nil
	end


	
	if INPUT.inputs[hash("up")] and not (state == "jump") then
		movement_vector.y = jump_step
		state = "jump"
	end


	
	local new_pos = pos + movement_vector * freq
	local up, down, left, right = {}, {}, {}, {}

	if vmath.length(movement_vector) > 0 then
		table.insert(up, physics.raycast(new_pos, new_pos + vmath.vector3(-co_size + margin, co_size, 0), {hash("world")}))
		table.insert(up, physics.raycast(new_pos, new_pos + vmath.vector3(co_size - margin, co_size, 0), {hash("world")}))
		table.insert(down, physics.raycast(new_pos, new_pos + vmath.vector3(-co_size + margin, -co_size, 0), {hash("world")}))
		table.insert(down, physics.raycast(new_pos, new_pos + vmath.vector3(co_size - margin, -co_size, 0), {hash("world")}))
		table.insert(left, physics.raycast(new_pos + vmath.vector3(co_size, co_size - margin, 0), new_pos + vmath.vector3(-co_size, co_size - margin, 0), {hash("world")}))
		table.insert(left, physics.raycast(new_pos + vmath.vector3(co_size, -co_size + margin, 0), new_pos + vmath.vector3(-co_size, -co_size + margin, 0), {hash("world")}))
		msg.post("@render:", "draw_line", {start_point = new_pos + vmath.vector3(co_size, -co_size + margin, 0), end_point = new_pos + vmath.vector3(-co_size, -co_size + margin, 0), color = vmath.vector4(1, 0, 0, 1)})
		table.insert(right, physics.raycast(new_pos, new_pos + vmath.vector3(co_size, co_size - margin, 0), {hash("world")}))
		table.insert(right, physics.raycast(new_pos, new_pos + vmath.vector3(co_size, -co_size + margin, 0), {hash("world")}))
		--msg.post("@render:", "draw_line", {start_point = new_pos, end_point = left[1].position, color = vmath.vector4(1, 0, 0, 1)})


		print(#up, #down, #left, #right)
		if false and #up > 0 and #down > 0 and #left > 0 and #right > 0 then
			go.set("#sprite", "tint", vmath.vector4(1, 0, 0, 1))
			pos_override = {}
			state = nil
			movement_vector.y = 0
			movement_vector.x = 0
		else
			if movement_vector.x < 0 then
				for key, val in ipairs(left) do
					if pos_override.x then
						pos_override.x = math.max(pos_override.x, val.position.x + (size / 2))--, new_pos.x)
					else
						pos_override.x = val.position.x + (size / 2)
					end
				end
			elseif movement_vector.x > 0 then
				for key, val in ipairs(right) do
					if pos_override.x then
						pos_override.x = math.min(pos_override.x, val.position.x - (size / 2), new_pos.x)
					else
						pos_override.x = val.position.x - (size / 2)
					end
				end
			end
			if movement_vector.y < 0 then
				for key, val in ipairs(down) do
					if pos_override.y then
						pos_override.y = math.max(pos_override.y, val.position.y + (size / 2), new_pos.y)
					else
						pos_override.y = val.position.y + (size / 2)
					end
					movement_vector.y = 0
				end
			elseif movement_vector.y > 0 then
				for key, val in ipairs(up) do
					if pos_override.y then
						pos_override.y = math.min(pos_override.y, val.position.y - (size / 2), new_pos.y)
					else
						pos_override.y = val.position.y - (size / 2)
					end
					movement_vector.y = 0
				end
			end
			go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))
		end

	end
	new_pos.x = pos_override.x or new_pos.x
	new_pos.y = pos_override.y or new_pos.y
	go.set_position(new_pos)
	
	local width, height = window.get_size()
	local cam_pos = vmath.vector3(-width / 2, -height / 2, 0) + go.get_world_position()
	go.animate("/cam", "position", go.PLAYBACK_ONCE_FORWARD, cam_pos, go.EASING_INOUTSINE, freq / 60)
	--go.set_position(cam_pos, "/cam")
	update_timer = timer.delay(freq / 60, false, upd)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection", {near = -1, far = 1})
	msg.post("/cam", hash("acquire_camera_focus"))
	upd(self)
end

function on_input(self, action_id, action)
	if action_id then
		local key_pressed = INPUT.key[action_id]
		if action.pressed then
			if key_pressed == hash("speed_up") then
				freq = math.max(freq / math.sqrt(2), 0.25)
			elseif key_pressed == hash("slow_down") then
				freq = math.min(freq * math.sqrt(2), 16)
			elseif key_pressed == hash("special") then

			end
		end
		if key_pressed then
			INPUT.inputs[key_pressed] = action.pressed or not action.released
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		
	elseif message_id == hash("contact_point_response") then
		
	end
end