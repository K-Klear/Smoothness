local INPUT = require("modules.input")

local smooth = 10
local base_step = 8
local jump_step = 16
local freq = 1
local update_timer
local next_freq = 0
local prev_pos

local not_col = {}
local state
local movement_vector = vmath.vector3(0, 0, 0)

local size = 80

local function upd(self)
	local pos = go.get_world_position()
	if INPUT.inputs[hash("left")] then-- and not_col[hash("left")] then
	movement_vector.x = -base_step
	elseif INPUT.inputs[hash("right")] then --and not_col[hash("right")] then
		movement_vector.x = base_step
	else
		movement_vector.x = 0
	end
	if INPUT.inputs[hash("up")] then --and not state then
		movement_vector.y = jump_step
		state = "jump"
	else
		local ray_1 = physics.raycast(pos + vmath.vector3(-(size / 2), -size, 0), pos + vmath.vector3(-(size / 2), -((size / 2) + 5), 0), {hash("world")})
		local ray_2 = physics.raycast(pos + vmath.vector3((size / 2), -size, 0), pos + vmath.vector3((size / 2), -((size / 2) + 5), 0), {hash("world")})
		if ray_1 or ray_2 then
			movement_vector.y = movement_vector.y - (0.2 * freq)
		else
			movement_vector.y = 0
			state = nil
		end
		if not not_col[hash("top")] and movement_vector.y > 0 then
			movement_vector.y = 0
			state = "jump"
		end
	end

	if vmath.length(movement_vector) > 0 then
		local function get_minus(num)
			local result
			if num > 0 then
				result = 1
			elseif num < 0 then
				result = -1
			else
				result = 0
			end
			return result
		end
		local dir_x = get_minus(movement_vector.x)
		if not (dir_x == 0) then
			local ray_1 = physics.raycast(pos + vmath.vector3(dir_x * size, (size / 2), 0), pos + vmath.vector3(dir_x * ((size / 2) + 5), (size / 2), 0), {hash("world")})
			local ray_2 = physics.raycast(pos + vmath.vector3(dir_x * size, -(size / 2), 0), pos + vmath.vector3(dir_x * ((size / 2) + 5), -(size / 2), 0), {hash("world")})
			if not (ray_1 and ray_2) then
				movement_vector.x = 0
			end
		end
		local dir_y = get_minus(movement_vector.y)
		if not (dir_y == 0) then
			local ray_1 = physics.raycast(pos + vmath.vector3(-(size / 2), dir_y * size, 0), pos + vmath.vector3(-(size / 2), dir_y * ((size / 2) + 5), 0), {hash("world")})
			local ray_2 = physics.raycast(pos + vmath.vector3((size / 2), dir_y * size, 0), pos + vmath.vector3((size / 2), dir_y * ((size / 2) + 5), 0), {hash("world")})
			if not (ray_1 and ray_2) then
				movement_vector.y = 0
			end
		end

	end

	local new_pos = pos + movement_vector * freq
	go.set_position(new_pos)
	
	local width, height = window.get_size()
	local cam_pos = vmath.vector3(-width / 2, -height / 2, 0) + go.get_world_position()
	go.animate("/cam", "position", go.PLAYBACK_ONCE_FORWARD, cam_pos, go.EASING_INOUTSINE, freq / 60)
	--go.set_position(cam_pos, "/cam")
	update_timer = timer.delay(freq / 60, false, upd)
	pprint(not_col)
	if (not_col[hash("tl")] and not_col[hash("tr")] and not_col[hash("br")] and not_col[hash("bl")]) then
		go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))
	else
		go.set("#sprite", "tint", vmath.vector4(1, 0, 0, 1))
	end
	not_col = {}
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection", {near = -1, far = 1})
	msg.post("/cam", hash("acquire_camera_focus"))
	upd(self)
end

function on_input(self, action_id, action)
	if action_id then
		local key_pressed = INPUT.key[action_id]
		if action.pressed then
			if key_pressed == hash("speed_up") then
				freq = math.max(freq / math.sqrt(2), 0.25)
			elseif key_pressed == hash("slow_down") then
				freq = math.min(freq * math.sqrt(2), 16)
			elseif key_pressed == hash("special") then

			end
		end
		if key_pressed then
			INPUT.inputs[key_pressed] = action.pressed or not action.released
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		not_col[message.own_group] = true
	elseif message_id == hash("contact_point_response") then

		--print(go.get_world_position(), (message.distance * message.normal))
		--go.set_position(go.get_world_position() + (message.distance * message.normal)) 
	end
end