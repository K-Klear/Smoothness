local INPUT = require("modules.input")

local smooth = 10
local base_step = 8
local jump_step = 16
local freq = 1
local update_timer
local next_freq = 0
local prev_pos

local state
local movement_vector = vmath.vector3(0, 0, 0)

local size = 80
local margin = 5

local function upd(self)
	local pos_override = {}
	local pos = go.get_world_position()
	if INPUT.inputs[hash("left")] then
	movement_vector.x = -base_step
	elseif INPUT.inputs[hash("right")] then
		movement_vector.x = base_step
	else
		movement_vector.x = 0
	end
	if INPUT.inputs[hash("up")] then --and not (state == "jump") then
		movement_vector.y = jump_step
		state = "jump"
	end

	movement_vector.y = movement_vector.y - (0.2 * freq)

	if vmath.length(movement_vector) > 0 then

		local new_pos = pos + movement_vector * freq
		local co_size = (size / 2) - 1

		local up = {
			physics.raycast(new_pos, new_pos + vmath.vector3(-co_size, co_size, 0), {hash("world")}),
			physics.raycast(new_pos, new_pos + vmath.vector3(co_size, co_size, 0), {hash("world")})
		}
		local down = {
			physics.raycast(new_pos, new_pos + vmath.vector3(-co_size, -co_size, 0), {hash("world")}),
			physics.raycast(new_pos, new_pos + vmath.vector3(co_size, -co_size, 0), {hash("world")})
		}
		local left = {
			physics.raycast(new_pos, new_pos + vmath.vector3(-co_size, co_size, 0), {hash("world")}),
			physics.raycast(new_pos, new_pos + vmath.vector3(-co_size, -co_size, 0), {hash("world")})
		}
		local right = {
			physics.raycast(new_pos, new_pos + vmath.vector3(co_size, co_size, 0), {hash("world")}),
			physics.raycast(new_pos, new_pos + vmath.vector3(co_size, -co_size, 0), {hash("world")})
		}


		if #up > 0 and #down > 0 and #left > 0 and #right > 0 then
			go.set("#sprite", "tint", vmath.vector4(1, 0, 0, 1))
			pos_override = {}
			state = nil
			movement_vector.y = 0
			movement_vector.x = 0
		else
			for key, val in ipairs(left) do
				if pos_override.x then
					pos_override.x = math.max(pos_override.x, val.position.x - (size / 2), pos.x + movement_vector.x * freq)
				else
					pos_override.x = val.position.x
				end
			end
			for key, val in ipairs(right) do
				if pos_override.x then
					pos_override.x = math.min(pos_override.x, val.position.x + (size / 2), pos.x + movement_vector.x * freq)
				else
					pos_override.x = val.position.x
				end
			end
			for key, val in ipairs(down) do
				if pos_override.y then
					pos_override.y = math.max(pos_override.y, val.position.y - (size / 2), pos.y + movement_vector.y * freq)
				else
					pos_override.y = val.position.y
				end
				movement_vector.y = 0
			end
			for key, val in ipairs(up) do
				if pos_override.y then
					pos_override.y = math.min(pos_override.y, val.position.y + (size / 2), pos.y + movement_vector.y * freq)
				else
					pos_override.y = val.position.y
				end
				movement_vector.y = 0
			end
			go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))
		end
		print(#up, #down, #left, #right)

	end
	local new_pos = pos + movement_vector * freq
	new_pos.x = pos_override.x or new_pos.x
	new_pos.y = pos_override.y or new_pos.y
	go.set_position(new_pos)
	
	local width, height = window.get_size()
	local cam_pos = vmath.vector3(-width / 2, -height / 2, 0) + go.get_world_position()
	go.animate("/cam", "position", go.PLAYBACK_ONCE_FORWARD, cam_pos, go.EASING_INOUTSINE, freq / 60)
	--go.set_position(cam_pos, "/cam")
	update_timer = timer.delay(freq / 60, false, upd)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection", {near = -1, far = 1})
	msg.post("/cam", hash("acquire_camera_focus"))
	upd(self)
end

function on_input(self, action_id, action)
	if action_id then
		local key_pressed = INPUT.key[action_id]
		if action.pressed then
			if key_pressed == hash("speed_up") then
				freq = math.max(freq / math.sqrt(2), 0.25)
			elseif key_pressed == hash("slow_down") then
				freq = math.min(freq * math.sqrt(2), 16)
			elseif key_pressed == hash("special") then

			end
		end
		if key_pressed then
			INPUT.inputs[key_pressed] = action.pressed or not action.released
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		
	elseif message_id == hash("contact_point_response") then
		
	end
end