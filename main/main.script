local INPUT = require("modules.input")

go.property("freq", 1)
go.property("RTX_on", true)


local base_step, jump_step = 8, 8
local size, margin = 48, 2
local freq_list = {60, 30, 15, 10, 5, 2, 1}

local function upd(self)
	local pos_override = {}
	local pos = go.get_world_position()
	local co_size = (size / 2)
	local up, down, left, right = {}, {}, {}, {}

	if self.state == "glitched" then

	else
		if INPUT.inputs[hash("left")] then
			self.movement_vector.x = -base_step
		elseif INPUT.inputs[hash("right")] then
			self.movement_vector.x = base_step
		else
			self.movement_vector.x = 0
		end

		local ray_1, ray_2
		ray_1 = physics.raycast(pos + vmath.vector3(-co_size + margin, co_size, 0), pos + vmath.vector3(-co_size + margin, -co_size - margin, 0), {hash("world")})
		ray_2 = physics.raycast(pos + vmath.vector3(co_size - margin, co_size, 0), pos + vmath.vector3(co_size - margin, -co_size - margin, 0), {hash("world")})
		if (ray_1 == nil and ray_2 == nil) then
			self.movement_vector.y = self.movement_vector.y - (0.2 * (60 / freq_list[self.freq]))
		elseif INPUT.inputs[hash("up")] then
			self.movement_vector.y = jump_step
			self.state = "jump"
		end

		local new_pos = pos + self.movement_vector * (60 / freq_list[self.freq])

		up, down, left, right = {}, {}, {}, {}
		_up, _down, _left, _right = {}, {}, {}, {}

		local _new_pos = vmath.vector3(pos.x, new_pos.y, 0)
		table.insert(up, physics.raycast(_new_pos + vmath.vector3(-co_size + margin, -co_size, 0), _new_pos + vmath.vector3(-co_size + margin, co_size, 0), {hash("world")}))
		table.insert(up, physics.raycast(_new_pos + vmath.vector3(co_size - margin, -co_size, 0), _new_pos + vmath.vector3(co_size - margin, co_size, 0), {hash("world")}))
		table.insert(_up, physics.raycast(_new_pos + vmath.vector3(-co_size + margin, co_size, 0), _new_pos + vmath.vector3(-co_size + margin, -co_size, 0), {hash("space")}))
		table.insert(_up, physics.raycast(_new_pos + vmath.vector3(co_size - margin, co_size, 0), _new_pos + vmath.vector3(co_size - margin, -co_size, 0), {hash("space")}))
		table.insert(down, physics.raycast(_new_pos + vmath.vector3(-co_size + margin, co_size, 0), _new_pos + vmath.vector3(-co_size + margin, -co_size, 0), {hash("world")}))
		table.insert(down, physics.raycast(_new_pos + vmath.vector3(co_size - margin, co_size, 0), _new_pos + vmath.vector3(co_size - margin, -co_size, 0), {hash("world")}))
		table.insert(_down, physics.raycast(_new_pos + vmath.vector3(-co_size + margin, -co_size, 0), _new_pos + vmath.vector3(-co_size + margin, co_size, 0), {hash("space")}))
		table.insert(_down, physics.raycast(_new_pos + vmath.vector3(co_size - margin, -co_size, 0), _new_pos + vmath.vector3(co_size - margin, co_size, 0), {hash("space")}))
		_new_pos = vmath.vector3(new_pos.x, pos.y, 0)
		table.insert(left, physics.raycast(_new_pos + vmath.vector3(co_size, co_size - margin, 0), _new_pos + vmath.vector3(-co_size, co_size - margin, 0), {hash("world")}))
		table.insert(left, physics.raycast(_new_pos + vmath.vector3(co_size, -co_size + margin, 0), _new_pos + vmath.vector3(-co_size, -co_size + margin, 0), {hash("world")}))
		table.insert(_left, physics.raycast(_new_pos + vmath.vector3(-co_size, co_size - margin, 0), _new_pos + vmath.vector3(co_size, co_size - margin, 0), {hash("space")}))
		table.insert(_left, physics.raycast(_new_pos + vmath.vector3(-co_size, -co_size + margin, 0), _new_pos + vmath.vector3(co_size, -co_size + margin, 0), {hash("space")}))
		table.insert(right, physics.raycast(_new_pos + vmath.vector3(-co_size, co_size - margin, 0), _new_pos + vmath.vector3(co_size, co_size - margin, 0), {hash("world")}))
		table.insert(right, physics.raycast(_new_pos + vmath.vector3(-co_size, -co_size + margin, 0), _new_pos + vmath.vector3(co_size, -co_size + margin, 0), {hash("world")}))
		table.insert(_right, physics.raycast(_new_pos + vmath.vector3(co_size, co_size - margin, 0), _new_pos + vmath.vector3(-co_size, co_size - margin, 0), {hash("space")}))
		table.insert(_right, physics.raycast(_new_pos + vmath.vector3(co_size, -co_size + margin, 0), _new_pos + vmath.vector3(-co_size, -co_size + margin, 0), {hash("space")}))
		
		if self.movement_vector.x < 0 and #_left > 0 then
			for key, val in ipairs(left) do
				if pos_override.x then
					pos_override.x = math.max(pos_override.x, val.position.x + (size / 2))--, new_pos.x)
				else
					pos_override.x = val.position.x + (size / 2)
				end
			end
		elseif self.movement_vector.x > 0 and #_right > 0 then
			for key, val in ipairs(right) do
				if pos_override.x then
					pos_override.x = math.min(pos_override.x, val.position.x - (size / 2), new_pos.x)
				else
					pos_override.x = val.position.x - (size / 2)
				end
			end
		end
		if self.movement_vector.y < 0 and #_down > 0 then
			for key, val in ipairs(down) do
				if pos_override.y then
					pos_override.y = math.max(pos_override.y, val.position.y + (size / 2), new_pos.y)
				else
					pos_override.y = val.position.y + (size / 2)
				end
				self.movement_vector.y = 0
				new_pos.y = pos.y
				self.state = nil
			end
		elseif self.movement_vector.y > 0 and #_up > 0 then
			for key, val in ipairs(up) do
				if pos_override.y then
					pos_override.y = math.min(pos_override.y, val.position.y - (size / 2), new_pos.y)
				else
					pos_override.y = val.position.y - (size / 2)
				end
				self.movement_vector.y = 0
				new_pos.y = pos.y
			end
		end
		go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))

		new_pos.x = pos_override.x or new_pos.x
		new_pos.y = pos_override.y or new_pos.y
		go.set_position(new_pos)
	end
	--update_timer = timer.delay(1 / freq_list[self.freq], false, upd)
end

local function switch_graphics(self, state)
	if state == nil then
		self.RTX_on = not self.RTX_on
	else
		self.RTX_on = state
	end
	tilemap.set_visible("world#tilemap", "gfx", self.RTX_on)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.movement_vector = vmath.vector3(0, 0, 0)
	switch_graphics(self, self.RTX_on)
	INPUT.inputs = {}
	msg.post("/gui", hash("change_frequency"), {freq = freq_list[self.freq]})

	local tiles = {
		[0] = 2, [19] = 4
	}
	for x = 1, 20 do
		for y = 1, 12 do
			local tile = tilemap.get_tile("world#tilemap", "gfx", x, y)
			tilemap.set_tile("world#tilemap", "layer", x, y, tiles[tile] or 1)
		end
	end
	self.move_indicator = factory.create("#move_indicator", vmath.vector3(140, 40, 0), nil, nil, vmath.vector3(10, 1, 1))
end

function on_input(self, action_id, action)
	if action_id then
		local key_pressed = INPUT.key[action_id]
		if action.pressed then
			if key_pressed == hash("speed_up") then
				if freq_list[self.freq - 1] then
					self.freq = self.freq - 1
				end
				msg.post("/gui", hash("change_frequency"), {freq = freq_list[self.freq]})
			elseif key_pressed == hash("slow_down") then
				if freq_list[self.freq + 1] then
					self.freq = self.freq + 1
				end
				msg.post("/gui", hash("change_frequency"), {freq = freq_list[self.freq]})
			elseif key_pressed == hash("special") then

			end
		end
		if key_pressed then
			INPUT.inputs[key_pressed] = action.pressed or not action.released
		end
	end
end

function update(self, dt)
	if self.frame then
		self.frame = self.frame + 1
		if self.frame % (60 / freq_list[self.freq]) + 1 == 1 then
			go.set(msg.url(nil, self.move_indicator, "sprite"), "tint.w", 1)
			upd(self)
		else
			local bar_scale = self.frame % (60 / freq_list[self.freq]) / (60 / freq_list[self.freq])
			go.set(msg.url(nil, self.move_indicator, "sprite"), "tint.w", bar_scale)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("delete_level") then
		go.delete("world")
		go.delete(self.move_indicator)
		self.move_indicator = nil
		go.delete()
	elseif message_id == hash("start") then
		self.frame = 0
	elseif message_id == hash("collision_response") then
		if message.other_group == hash("exit") and not self.finished then
			self.finished = true
			msg.post("/gui#menu", hash("level_complete"))
		end
	elseif message_id == hash("contact_point_response") then

	elseif message_id == hash("trigger_response") then

	end
end